
/**
 * QZ Tray Connector
 * version 2.2.1                                  
 * https://qz.io
 *
 * License: GNU LGPL 2.1
 * https://raw.githubusercontent.com/qzind/tray/master/LICENSE
 */
var qz=function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=0)}([function(e,t,n){"use strict";n.r(t);var r={};n.r(r),n.d(r,"callValue",function(){return p}),n.d(r,"Dummy",function(){return u}),n.d(r,"DummyDialog",function(){return w}),n.d(r,"DummyEntry",function(){return y}),n.d(r,"DummyFile",function(){return b}),n.d(r,"DummyList",function(){return T}),n.d(r,"DummyMedia",function(){return O}),n.d(r,"DummyNumber",function(){return S}),n.d(r,"DummyRadio",function(){return E}),n.d(r,"DummyServer",function(){return L}),n.d(r,"DummyText",function(){return j}),n.d(r,"DummyWebApp",function(){return A}),n.d(r,"DummyWebView",function(){return M});var o=function(e){if(i){if("string"==typeof e)return e;switch(e){case KeepSettings.DEFAULT:return"default";case KeepSettings.REUSE:return"reuse";case KeepSettings.CLEAR:return"clear";default:return"default"}}return e},i=!(!document||document.location.search.indexOf("mock=true")<0),a=new Map,c=new Map;function s(){var e=function(e,t){var n=[];return a.forEach(function(r,o){var i=r.regex&&r.regex.test(e)?r.connect(t):Promise.reject("Not handled");n.push({promise:i,socket:o})}),n},t=function(t,n,r){return void 0===r&&(r={}),i?Promise.reject("MockWS wants to send data to a WebSocket, but there is no WebSocket defined"):e(t,r).length>0?Promise.all(e(t,r).map(function(e){return new Promise(function(i,a){e.promise.then(function(){n(e.socket,!0),i()}).catch(function(){n(e.socket,!1),a("Unhandled message to host")})})})):Promise.reject("No active WebSockets able to send message")};return{setCharacteristics:function(e){c=e},getCharacteristics:function(){return c},mockWebSocketPromise:function(e,n,r,o){var i,s=function(){return o?o:function(){return!1}};return i=r?Promise.resolve():Promise.reject(),a.set(e,{connect:function(){return i},regex:n,active:s}),i},unmockWebSocketPromise:function(e){a.delete(e)},mockConnect:function(e){t(""; case KeepSettings.REUSE: return "reuse"; case KeepSettings.CLEAR: return "clear"; default: return "default"; } } return e; }, isMockMode = !(!document || document.location.search.indexOf("mock=true") < 0), webSocketMap = new Map(), charMap = new Map(); function MockWebsockets() { var e = function (e, t) { var n = []; return webSocketMap.forEach(function (r, o) { var i = r.regex && r.regex.test(e) ? r.connect(t) : Promise.reject("Not handled"); n.push({ promise: i, socket: o }) }), n }, t = function (t, n, r) { return void 0 === r && (r = {}), isMockMode ? Promise.reject("MockWS wants to send data to a WebSocket, but there is no WebSocket defined") : e(t, r).length > 0 ? Promise.all(e(t, r).map(function (e) { return new Promise(function (i, a) { e.promise.then(function () { n(e.socket, !0), i() }).catch(function () { n(e.socket, !1), a("Unhandled message to host") }) }) })) : Promise.reject("No active WebSockets able to send message") }; return { setCharacteristics: function (e) { charMap = e }, getCharacteristics: function () { return charMap }, mockWebSocketPromise: function (e, n, r, o) { var i, a = function () { return o ? o : function () { return !1 } }; return i = r ? Promise.resolve() : Promise.reject(), webSocketMap.set(e, { connect: function () { return i }, regex: n, active: a }), i }, unmockWebSocketPromise: function (e) { webSocketMap.delete(e) }, mockConnect: function (e) { t("connect", e) }, mockClose: function (e) { t("close", e) }, sendData: t } } var MockCertificatePrompt = function () { return { prompt: function (e, t, n) { if (isMockMode) { var r = new Certificate(); return r.commonName = "mock-cert", r.organization = "QZ Mock", r.valid = !0, r.trusted = n, n ? Promise.resolve(r) : Promise.reject(r) } return Promise.reject("Certificate prompt called when not in mock mode") } }; }, MockPrintSocket = function () { return { websocket: MockWebsockets(), certificate: MockCertificatePrompt() } }; function callValue(e) { var t = Array.prototype.slice.call(arguments); return t.shift(), e instanceof Function ? e.apply(e, t) : e } var Dummy = function () { function e() { } return e.setup = function () { }, e.teardown = function () { }, e }(), DummyDialog = function () { function e() { } return e.internalOnMessagePrompt = function (e, t, n, r) { return this.onMessagePrompt ? this.onMessagePrompt(e, t, n, r) : Promise.reject("No onMessagePrompt registered") }, e.internalOnDoublePrompt = function (e, t, n, r, o) { return this.onDoublePrompt ? this.onDoublePrompt(e, t, n, r, o) : Promise.reject("No onDoublePrompt registered") }, e.internalOnFilePrompt = function (e, t, n, r, o) { return this.onFilePrompt ? this.onFilePrompt(e, t, n, r, o) : Promise.reject("No onFilePrompt registered") }, e.internalOnListPrompt = function (e, t, n, r, o) { return this.onListPrompt ? this.onListPrompt(e, t, n, r, o) : Promise.reject("No onListPrompt registered") }, e.internalOnEntryPrompt = function (e, t, n, r, o) { return this.onEntryPrompt ? this.onEntryPrompt(e, t, n, r, o) : Promise.reject("No onEntryPrompt registered") }, e.internalOnConfirmPrompt = function (e, t, n, r) { return this.onConfirmPrompt ? this.onConfirmPrompt(e, t, n, r) : Promise.reject("No onConfirmPrompt registered") }, e }(), DummyEntry = function () { function e() { } return e.internalOnDisplayChange = function (e, t) { return this.onDisplayChange ? this.onDisplayChange(e, t) : Promise.reject("No onDisplayChange registered") }, e.internalOnWindowState = function (e, t) { return this.onWindowState ? this.onWindowState(e, t) : Promise.reject("No onWindowState registered") }, e.internalOnInputShield = function (e, t) { return this.onInputShield ? this.onInputShield(e, t) : Promise.reject("No onInputShield registered") }, e.internalOnAlignWindow = function (e, t, n, r, o, i) { return this.onAlignWindow ? this.onAlignWindow(e, t, n, r, o, i) : Promise.reject("No onAlignWindow registered") }, e }(), DummyFile = function () { function e() { } return e.internalOnRead = function (e) { return this.onRead ? this.onRead(e) : Promise.reject("No onRead registered") }, e.internalOnWrite = function (e, t, n) { return this.onWrite ? this.onWrite(e, t, n) : Promise.reject("No onWrite registered") }, e.internalOnList = function (e, t) { return this.onList ? this.onList(e, t) : Promise.reject("No onList registered") }, e.internalOnSize = function (e) { return this.onSize ? this.onSize(e) : Promise.reject("No onSize registered") }, e }(), DummyList = function () { function e() { } return e.internalOnPrinter = function (e, t) { return this.onPrinter ? this.onPrinter(e, t) : Promise.reject("No onPrinter registered") }, e.internalOnFile = function (e, t, n) { return this.onFile ? this.onFile(e, t, n) : Promise.reject("No onFile registered") }, e.internalOnUsb = function () { return this.onUsb ? this.onUsb() : Promise.reject("No onUsb registered") }, e.internalOnHid = function () { return this.onHid ? this.onHid() : Promise.reject("No onHid registered") }, e.internalOnSoftwareVersion = function () { return this.onSoftwareVersion ? this.onSoftwareVersion() : Promise.reject("No onSoftwareVersion registered") }, e.internalOnSystemInformation = function () { return this.onSystemInformation ? this.onSystemInformation() : Promise.reject("No onSystemInformation registered") }, e.internalOnEnvironmentVariable = function (e) { return this.onEnvironmentVariable ? this.onEnvironmentVariable(e) : Promise.reject("No onEnvironmentVariable registered") }, e.internalOnNetworkInterfaces = function () { return this.onNetworkInterfaces ? this.onNetworkInterfaces() : Promise.reject("No onNetworkInterfaces registered") }, e }(), DummyMedia = function () { function e() { } return e.internalOnTray = function (e) { return this.onTray ? this.onTray(e) : Promise.reject("No onTray registered") }, e }(), DummyNumber = function () { function e() { } return e.internalOnCpuUsage = function (e) { return this.onCpuUsage ? this.onCpuUsage(e) : Promise.reject("No onCpuUsage registered") }, e.internalOnMemoryUsage = function () { return this.onMemoryUsage ? this.onMemoryUsage() : Promise.reject("No onMemoryUsage registered") }, e.internalOnProcessCount = function () { return this.onProcessCount ? this.onProcessCount() : Promise.reject("No onProcessCount registered") }, e.internalOnScreenCount = function () { return this.onScreenCount ? this.onScreenCount() : Promise.reject("No onScreenCount registered") }, e }(), DummyRadio = function () { function e() { } return e.internalOnSetup = function (e, t, n, r) { return this.onSetup ? this.onSetup(e, t, n, r) : Promise.reject("No onSetup registered") }, e.internalOnIdentity = function (e, t, n, r, o, i) { return this.onIdentity ? this.onIdentity(e, t, n, r, o, i) : Promise.reject("No onIdentity registered") }, e.internalOnScan = function (e, t) { return this.onScan ? this.onScan(e, t) : Promise.reject("No onScan registered") }, e.internalOnStart = function (e) { return this.onStart ? this.onStart(e) : Promise.reject("No onStart registered") }, e.internalOnStop = function (e) { return this.onStop ? this.onStop(e) : Promise.reject("No onStop registered") }, e.internalOnWrite = function (e, t, n) { return this.onWrite ? this.onWrite(e, t, n) : Promise.reject("No onWrite registered") }, e.internalOnWriteBulk = function (e, t) { return this.onWriteBulk ? this.onWriteBulk(e, t) : Promise.reject("No onWriteBulk registered") }, e }(), DummyServer = function () { function e() { } return e.internalOnFind = function (e) { return this.onFind ? this.onFind(e) : Promise.reject("No onFind registered") }, e }(), DummyText = function () { function e() { } return e.internalOnDesk = function (e, t) { return this.onDesk ? this.onDesk(e, t) : Promise.reject("No onDesk registered") }, e.internalOnConsole = function (e) { return this.onConsole ? this.onConsole(e) : Promise.reject("No onConsole registered") }, e }(), DummyWebApp = function () { function e() { } return e.internalOnNavigate = function (e, t) { return this.onNavigate ? this.onNavigate(e, t) : Promise.reject("No onNavigate registered") }, e }(), DummyWebView = function () { function e() { } return e.internalOnRegister = function (e) { return this.onRegister ? this.onRegister(e) : Promise.reject("No onRegister registered") }, e.internalOnUnregister = function (e) { return this.onUnregister ? this.onUnregister(e) : Promise.reject("No onUnregister registered") }, e.internalOnHistory = function (e, t, n) { return this.onHistory ? this.onHistory(e, t, n) : Promise.reject("No onHistory registered") }, e.internalOnRefresh = function (e) { return this.onRefresh ? this.onRefresh(e) : Promise.reject("No onRefresh registered") }, e.internalOnStop = function (e) { return this.onStop ? this.onStop(e) : Promise.reject("No onStop registered") }, e.internalOnInterrupt = function (e, t) { return this.onInterrupt ? this.onInterrupt(e, t) : Promise.reject("No onInterrupt registered") }, e.internalOnBounds = function (e, t, n, r, o) { return this.onBounds ? this.onBounds(e, t, n, r, o) : Promise.reject("No onBounds registered") }, e.internalOnMove = function (e, t, n) { return this.onMove ? this.onMove(e, t, n) : Promise.reject("No onMove registered") }, e.internalOnResize = function (e, t, n) { return this.onResize ? this.onResize(e, t, n) : Promise.reject("No onResize registered") }, e.internalOnScroll = function (e, t, n) { return this.onScroll ? this.onScroll(e, t, n) : Promise.reject("No onScroll registered") }, e.internalOnConfigurationChange = function (e, t, n, r, o, i, a, c, s, u, l, f, d, h, m, p, g) { return this.onConfigurationChange ? this.onConfigurationChange(e, t, n, r, o, i, a, c, s, u, l, f, d, h, m, p, g) : Promise.reject("No onConfigurationChange registered") }, e.internalOnVisibility = function (e, t) { return this.onVisibility ? this.onVisibility(e, t) : Promise.reject("No onVisibility registered") }, e.internalOnUa = function (e) { return this.onUa ? this.onUa(e) : Promise.reject("No onUa registered") }, e.internalOnDebug = function (e, t) { return this.onDebug ? this.onDebug(e, t) : Promise.reject("No onDebug registered") }, e.internalOnConsole = function (e, t) { return this.onConsole ? this.onConsole(e, t) : Promise.reject("No onConsole registered") }, e.internalOnFavicon = function (e) { return this.onFavicon ? this.onFavicon(e) : Promise.reject("No onFavicon registered") }, e.internalOnTitle = function (e) { return this.onTitle ? this.onTitle(e) : Promise.reject("No onTitle registered") }, e.internalOnDom = function (e, t) { return this.onDom ? this.onDom(e, t) : Promise.reject("No onDom registered") }, e }(); function QZShadow() { var e = this, t = MockPrintSocket(); this.printers = { find: function (e) { return isMockMode ? r.DummyList.internalOnPrinter(e, o(e)) : t.websocket.sendData(JSON.stringify({ command: "printers.find", params: { tree: e } }), function (t, n) { n && t && t.send(JSON.stringify({ command: "printers.find", init: { uuid: e, timestamp: Date.now() } })) }) }, getDefault: function () { return r.DummyList.internalOnPrinter ? r.DummyList.internalOnPrinter() : isMockMode ? r.DummyList.internalOnPrinter() : t.websocket.sendData(JSON.stringify({ command: "printers.getDefault", params: {} }), function (e, t) { t && e && e.send(JSON.stringify({ command: "printers.getDefault", init: { timestamp: Date.now() } })) }) }, setDefault: function (e) { return isMockMode ? Promise.resolve() : t.websocket.sendData(JSON.stringify({ command: "printers.setDefault", params: { printer: e } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "printers.setDefault", init: { timestamp: Date.now() } })) }) } }, this.ports = { usb: { list: function () { return isMockMode ? r.DummyList.internalOnUsb() : t.websocket.sendData(JSON.stringify({ command: "ports.usb.list", params: {} }), function (e, t) { t && e && e.send(JSON.stringify({ command: "ports.usb.list", init: { timestamp: Date.now() } })) }) } }, hid: { list: function () { return isMockMode ? r.DummyList.internalOnHid() : t.websocket.sendData(JSON.stringify({ command: "ports.hid.list", params: {} }), function (e, t) { t && e && e.send(JSON.stringify({ command: "ports.hid.list", init: { timestamp: Date.now() } })) }) } } }, this.websocket = { connect: function (n) { if (isMockMode) return r.mockConnect(), Promise.resolve(!0); var o = t.websocket.getCharacteristics(); void 0 === n && (n = {}); var i = n.host || "localhost", a = n.port || "8182", c = n.secure || !1, s = n.keepAlive || 60, u = n.retries || 0, l = n.delay || 0, f = "ws" + (c ? "s" : "") + "://" + i + ":" + a; return new Promise(function (r, i) { try { var c = function (c) { var d = 0, h = 0, m = function () { try { var c = new WebSocket(f); c.valid = !0, e.websocket.connection = c, c.hostname = f, c.connect_retries = h, e.websocket.setup(c), e.websocket.setProperties(c, n), void 0 !== o && o.size > 0 && (c.ses = o), "function" == typeof n.callback && n.callback(c), d = 0, h = 0, t.websocket.setCharacteristics(c.ses), r(!0) } catch (e) { if (h++, "number" == typeof u && u > 0 && h >= u) return i(e); try { var p = "number" == typeof l && l > 0 ? l : Math.pow(d, 2); setTimeout(m, 1e3 * p), d++ } catch (e) { i(e) } } }; m() }; if ("number" == typeof s && s > 0 || (console.log("Setting default 60s keep alive"), s = 60), navigator && navigator.serviceWorker && navigator.serviceWorker.controller) navigator.serviceWorker.addEventListener("message", function (e) { "connect" === e.data.command && (c(!0), navigator.serviceWorker.controller.postMessage({ command: "ws-connect", hostname: f, port: a, secure: n.secure, keepAlive: s, uuid: e.data.uuid, ack: !0 })) }, { once: !0 }), navigator.serviceWorker.controller.postMessage({ command: "ws-connect", hostname: f, port: a, secure: n.secure, keepAlive: s }); else { var d = function () { if (document.getElementsByTagName("body")[0] && !document.getElementById("qz-ws")) { var e = document.createElement("iframe"); e.id = "qz-ws", e.setAttribute("style", "position:absolute; top:-999px; left:-999px; height:1px; width:1px;"), document.getElementsByTagName("body")[0].appendChild(e), window.onkeydown = function (e) { return !e.ctrlKey || 80 !== e.keyCode || (e.preventDefault(), !1) }, window.onbeforeprint = function () { return !1 } } }; c({ target: { port: a } }), d() } } catch (e) { console.error(e), i(e) } }) }, disconnect: function () { if (isMockMode) return r.mockClose(e.websocket.connection), Promise.resolve(!0); var n = e.websocket.connection && e.websocket.connection.hostname || "", o = e.websocket.connection && e.websocket.connection.valid; return t.websocket.setCharacteristics({}), e.websocket.connection && (e.websocket.connection.ses = null, e.websocket.connection.terminal = !0, "open" === e.websocket.connection.readyState || "connecting" === e.websocket.connection.readyState ? new Promise(function (t, r) { try { e.websocket.connection.close(1e3, "Closed by client"), navigator && navigator.serviceWorker && navigator.serviceWorker.controller && navigator.serviceWorker.controller.postMessage({ command: "ws-disconnect", hostname: n, ack: !0 }), e.websocket.connection = null, t(!0) } catch (e) { console.error(e), r(e) } }) : (e.websocket.connection = null, navigator && navigator.serviceWorker && navigator.serviceWorker.controller && navigator.serviceWorker.controller.postMessage({ command: "ws-disconnect", hostname: n, ack: !0 }), o ? Promise.reject("Invalid session") : Promise.resolve(!0))) }, connection: null, setup: function (e) { e.onopen = function () { console.log("Open:"), "function" == typeof qz.websocket.openCallbacks && qz.websocket.openCallbacks.forEach(function (e) { e.call(!0) }) }, e.onclose = function () { console.log("Closed:"), function () { for (var t = Array.prototype.slice.call(document.getElementsByTagName("iframe")), n = 0; n < t.length; n++) "qz-ws" === t[n].id && (e.valid = !1) }(), "function" == typeof qz.websocket.closedCallbacks && qz.websocket.closedCallbacks.forEach(function (e) { e.call(!0) }) }, e.onerror = function (e) { console.log("Error:"), console.log(e), "function" == typeof qz.websocket.errorCallbacks && qz.websocket.errorCallbacks.forEach(function (t) { t.call(!0, e) }) }, e.onmessage = function (t) { console.log("Message:"); var n = document.getElementById("qz-ws"), r = JSON.parse(t.data); if (r.uid) if (navigator && navigator.serviceWorker && navigator.serviceWorker.controller) navigator.serviceWorker.controller.postMessage({ command: "ws-message", message: r }); else if (n && n.contentWindow) { var o = function (n, r, o) { n.addEventListener("message", function () { t.name === r && o() }) }; n.contentWindow.postMessage(r, "*"), o(e, "qzSocket", function () { }) } } }, setProperties: function (e, t) { void 0 !== t && (t.name && (e.name = t.name), t.secure && (e.secure = t.secure), t.processData && (e.processData = t.processData)) }, isActive: function () { return !!e.websocket.connection && "open" === e.websocket.connection.readyState }, setClosedCallbacks: function (e) { "function" == typeof e ? qz.websocket.closedCallbacks = [e] : qz.websocket.closedCallbacks = e }, setErrorCallbacks: function (e) { "function" == typeof e ? qz.websocket.errorCallbacks = [e] : qz.websocket.errorCallbacks = e }, setOpenCallbacks: function (e) { "function" == typeof e ? qz.websocket.openCallbacks = [e] : qz.websocket.openCallbacks = e }, setWebsocketMockPromises: t.websocket.mockWebSocketPromise, openCallbacks: [], errorCallbacks: [], closedCallbacks: [] }, this.file = { list: function (e, n) { return isMockMode ? r.DummyList.internalOnFile(e, n, o(n)) : t.websocket.sendData(JSON.stringify({ command: "file.list", params: { path: e, include: n } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "file.list", init: { timestamp: Date.now() } })) }) }, read: function (e) { return isMockMode ? r.DummyFile.internalOnRead(e) : t.websocket.sendData(JSON.stringify({ command: "file.read", params: { path: e } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "file.read", init: { timestamp: Date.now() } })) }) }, write: function (e, n, o) { return void 0 === o && (o = !1), isMockMode ? r.DummyFile.internalOnWrite(e, n, o) : t.websocket.sendData(JSON.stringify({ command: "file.write", params: { path: e, data: n, sandbox: o } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "file.write", init: { timestamp: Date.now() } })) }) }, exists: function (e) { return isMockMode ? Promise.resolve({ exists: !0 }) : t.websocket.sendData(JSON.stringify({ command: "file.exists", params: { path: e } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "file.exists", init: { timestamp: Date.now() } })) }) }, size: function (e) { return isMockMode ? r.DummyFile.internalOnSize(e) : t.websocket.sendData(JSON.stringify({ command: "file.size", params: { path: e } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "file.size", init: { timestamp: Date.now() } })) }) }, remove: function (e) { return isMockMode ? Promise.resolve() : t.websocket.sendData(JSON.stringify({ command: "file.remove", params: { path: e } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "file.remove", init: { timestamp: Date.now() } })) }) } }, this.certificate = { keychain: function (e) { if (isMockMode) { var n = t.certificate.prompt(!0, e, !0); return n } return t.websocket.sendData(JSON.stringify({ command: "certificate.keychain", params: { alias: e } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "certificate.keychain", init: { timestamp: Date.now() } })) }) }, embed: function (e) { var n = e || {}; return isMockMode ? (n.commonName = "Mock Embedded Certificate", Promise.resolve(n)) : t.websocket.sendData(JSON.stringify({ command: "certificate.embed", params: { alias: n.alias, data: n } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "certificate.embed", init: { timestamp: Date.now() } })) }) }, promise: function (e, n) { var o = e || {}, i = n || !1; if (isMockMode) { var a = t.certificate.prompt(i, e, !i); return a } return t.websocket.sendData(JSON.stringify({ command: "certificate.promise", params: { alias: o.alias, pin: o.pin, signature: o.signature, signAlgorithm: o.signAlgorithm, timestamp: o.timestamp, overwrite: i } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "certificate.promise", init: { timestamp: Date.now() } })) }) }, setWebsocketCertPromise: function (e, n, r) { t.certificate.prompt = function (t, o, i) { return e(t, o, i) } } }, this.hid = { list: e.ports.hid.list, write: function (e, n, o) { return isMockMode ? r.DummyRadio.internalOnWrite(e, n, o) : t.websocket.sendData(JSON.stringify({ command: "hid.write", params: { vendor: e, product: n, data: o } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "hid.write", init: { timestamp: Date.now() } })) }) }, readStream: function (e, n, o, i, a, c, s) { if (isMockMode) return r.DummyRadio.internalOnSetup(e, n, s, a); null == c && (c = 10); var u = 0; return new Promise(function (r, a) { if (e && n && o && i) try { var l = { init: function () { return t.websocket.sendData(JSON.stringify({ command: "hid.readStream.init", params: { vendorId: e, productId: n, usagePage: o, usage: i, callback: c, length: s } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "hid.readStream.init", init: { timestamp: Date.now() } })) }) }, initDataStream: function (t, l) { var f = function n(o) { var i = new RegExp(".*" + t + ".*"), a = JSON.parse(o.data); if ("HID_DATA" === a.command) { u++; var c = null; try { c = a.result.vendor === e && a.result.product === n && i.test(a.init.session), c && (l(a.result.data), u = 0) } catch (e) { console.log("ERROR", e) } } else if (!0 === a.exception) { if (a.exceptionType) throw a.exceptionType; throw a.exception } }; return f } }; l.init().then(function (e) { var t = r; e && e.data && (u = 0, qz.websocket.connection.addEventListener("message", l.initDataStream(e.eventId, function (e) { var n = null; try { n = a ? a(e) : e } catch (t) { n = e } "function" == typeof t && t(n) }))) }).catch(function (e) { a(e) }) } catch (e) { a(e) } else a("Vendor, product, page, and usage ID parameters are required") }) }, readOnce: function (e, n, o, i, a, c) { return isMockMode ? r.DummyRadio.internalOnScan(e, n) : t.websocket.sendData(JSON.stringify({ command: "hid.readOnce", params: { vendorId: e, productId: n, usagePage: o, usage: i, timeout: a, length: c } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "hid.readOnce", init: { timestamp: Date.now() } })) }) }, openStream: function (e, n, o, i) { return isMockMode ? r.DummyRadio.internalOnStart(e) : t.websocket.sendData(JSON.stringify({ command: "hid.openStream", params: { vendorId: e, productId: n, usagePage: o, usage: i } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "hid.openStream", init: { timestamp: Date.now() } })) }) }, closeStream: function (e) { return isMockMode ? r.DummyRadio.internalOnStop(e) : t.websocket.sendData(JSON.stringify({ command: "hid.closeStream", params: { vendorId: e } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "hid.closeStream", init: { timestamp: Date.now() } })) }) }, startListening: function (e, n, o, i, a, c, s) { if (isMockMode) return r.DummyRadio.internalOnIdentity(e, n, o, i, a, s); null == c && (c = 10); var u = 0; return new Promise(function (r, a) { if (e && n && o && i) try { var l = { init: function () { return t.websocket.sendData(JSON.stringify({ command: "hid.startListening", params: { vendorId: e, productId: n, usagePage: o, usage: i, callback: c, length: s } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "hid.startListening", init: { timestamp: Date.now() } })) }) }, initDataStream: function (t, l) { var f = function n(o) { var i = new RegExp(".*" + t + ".*"), a = JSON.parse(o.data); if ("HID_DATA" === a.command) { u++; var c = null; try { c = a.result.vendor === e && a.result.product === n && i.test(a.init.session), c && (l(a.result.data), u = 0) } catch (e) { console.log("ERROR", e) } } else if (!0 === a.exception) { if (a.exceptionType) throw a.exceptionType; throw a.exception } }; return f } }; l.init().then(function (e) { var t = r; e && e.data && (u = 0, qz.websocket.connection.addEventListener("message", l.initDataStream(e.eventId, function (e) { var n = null; try { n = a ? a(e) : e } catch (t) { n = e } "function" == typeof t && t(n) }))) }).catch(function (e) { a(e) }) } catch (e) { a(e) } else a("Vendor, product, page, and usage ID parameters are required") }) }, stopListening: function (e) { return isMockMode ? r.DummyRadio.internalOnStop(e) : t.websocket.sendData(JSON.stringify({ command: "hid.stopListening", params: { vendorId: e } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "hid.stopListening", init: { timestamp: Date.now() } })) }) }, bulkWrite: function (e, n, o) { return isMockMode ? r.DummyRadio.internalOnWriteBulk(e, o) : t.websocket.sendData(JSON.stringify({ command: "hid.bulkWrite", params: { vendorId: e, productId: n, data: o } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "hid.bulkWrite", init: { timestamp: Date.now() } })) }) } }, this.usb = { list: e.ports.usb.list, listInterfaces: function (e, n) { return isMockMode ? Promise.resolve(e, n, { iface: 0, description: "fake interface", endpoints: { input: 4227858434, output: 8422350850 } }) : t.websocket.sendData(JSON.stringify({ command: "usb.listInterfaces", params: { vendorId: e, productId: n } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "usb.listInterfaces", init: { timestamp: Date.now() } })) }) }, readData: function (e, n, o, i) { return isMockMode ? Promise.resolve({ vendorId: e, productId: n, interface: o, endpoint: i, response: null, data: "" }) : t.websocket.sendData(JSON.stringify({ command: "usb.readData", params: { vendorId: e, productId: n, interface: o, endpoint: i } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "usb.readData", init: { timestamp: Date.now() } })) }) }, sendData: function (e, n, o, i, a) { return isMockMode ? Promise.resolve({ vendorId: e, productId: n, interface: o, endpoint: i, data: a }) : t.websocket.sendData(JSON.stringify({ command: "usb.sendData", params: { vendorId: e, productId: n, interface: o, endpoint: i, data: a } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "usb.sendData", init: { timestamp: Date.now() } })) }) } }, this.system = { environmentVariable: function (e) { return isMockMode ? r.DummyList.internalOnEnvironmentVariable(e) : t.websocket.sendData(JSON.stringify({ command: "system.environmentVariable", params: { name: e } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "system.environmentVariable", init: { timestamp: Date.now() } })) }) }, getNetworkInterfaces: function () { return isMockMode ? r.DummyList.internalOnNetworkInterfaces() : t.websocket.sendData(JSON.stringify({ command: "system.networkInterfaces", params: {} }), function (e, t) { t && e && e.send(JSON.stringify({ command: "system.networkInterfaces", init: { timestamp: Date.now() } })) }) }, getVersion: function () { return isMockMode ? r.DummyList.internalOnSoftwareVersion() : t.websocket.sendData(JSON.stringify({ command: "system.version", params: {} }), function (e, t) { t && e && e.send(JSON.stringify({ command: "system.version", init: { timestamp: Date.now() } })) }) }, getAIVersion: function () { return Promise.resolve({ version: "2.2.1", timestamp: "2023-01-15T05:53:32.404Z", github: { commits: 2587, hash: "1fa380d9", date: "2023-01-15T05:46:25Z", branch: "master" } }) }, getOSVendor: function () { return Promise.resolve({ osVendor: "Ubuntu", osName: "Ubuntu 22.04.3 LTS", osVersion: "22.04", osArch: "amd64", osBits: "64" }) }, getInfo: function () { return isMockMode ? r.DummyList.internalOnSystemInformation() : t.websocket.sendData(JSON.stringify({ command: "system.info", params: {} }), function (e, t) { t && e && e.send(JSON.stringify({ command: "system.info", init: { timestamp: Date.now() } })) }) }, getAIInfo: function () { return Promise.resolve({ version: "2.2.1", timestamp: "2023-01-15T05:53:32.404Z", github: { commits: 2587, hash: "1fa380d9", date: "2023-01-15T05:46:25Z", branch: "master" }, libraryVersion: "2.2.1", platform: { osName: "Ubuntu", osArch: "amd64", osVersion: "22.04", osVendor: "Ubuntu 22.04.3 LTS" }, processingUnits: 8, hostScreens: 2, memory: { available: 18615193190, used: 7965934240, usagePercent: 42.79 }, permissions: { server: {} } }) }, getProcessCount: function () { return isMockMode ? r.DummyNumber.internalOnProcessCount() : t.websocket.sendData(JSON.stringify({ command: "system.processCount", params: {} }), function (e, t) { t && e && e.send(JSON.stringify({ command: "system.processCount", init: { timestamp: Date.now() } })) }) }, getScreenCount: function () { return isMockMode ? r.DummyNumber.internalOnScreenCount() : t.websocket.sendData(JSON.stringify({ command: "system.screenCount", params: {} }), function (e, t) { t && e && e.send(JSON.stringify({ command: "system.screenCount", init: { timestamp: Date.now() } })) }) }, getMemoryUsage: function () { return isMockMode ? r.DummyNumber.internalOnMemoryUsage() : t.websocket.sendData(JSON.stringify({ command: "system.memoryUsage", params: {} }), function (e, t) { t && e && e.send(JSON.stringify({ command: "system.memoryUsage", init: { timestamp: Date.now() } })) }) }, getCpuUsage: function (e) { return isMockMode ? r.DummyNumber.internalOnCpuUsage(e) : t.websocket.sendData(JSON.stringify({ command: "system.cpuUsage", params: { seconds: e } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "system.cpuUsage", init: { timestamp: Date.now() } })) }) }, websocket: { server: function (e) { return isMockMode ? r.DummyServer.internalOnFind(e) : t.websocket.sendData(JSON.stringify({ command: "websocket.server", params: { hostname: e } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "websocket.server", init: { timestamp: Date.now() } })) }) } } }, this.media = { tray: function (e) { return isMockMode ? r.DummyMedia.internalOnTray(e) : t.websocket.sendData(JSON.stringify({ command: "media.tray", params: { action: e } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "media.tray", init: { timestamp: Date.now() } })) }) } }, this.print = { setSerialPort: function (n) { return e.serial = n, isMockMode ? Promise.resolve() : t.websocket.sendData(JSON.stringify({ command: "printer.setSerialPort", params: { port: n } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "printer.setSerialPort", init: { timestamp: Date.now() } })) }) }, setOptions: function (n) { return e.printerOptions = n, isMockMode ? Promise.resolve() : t.websocket.sendData(JSON.stringify({ command: "printer.setOptions", params: { options: n } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "printer.setOptions", init: { timestamp: Date.now() } })) }) }, write: function (e) { return isMockMode ? Promise.resolve() : t.websocket.sendData(JSON.stringify({ command: "printer.write", params: { content: e } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "printer.write", init: { timestamp: Date.now() } })) }) }, processData: function (e) { return isMockMode ? Promise.resolve(e) : "string" == typeof e || "object" == typeof e && null !== e && "string" == typeof e.data ? Promise.resolve(e) : new Promise(function (t, n) { try { var r = new FileReader; r.onloadend = function (e) { var n = new Uint8Array(e.target.result); t({ type: "byte", format: "base64", data: function (e) { for (var t = "", n = 0; n < e.byteLength; n++) t += String.fromCharCode(e[n]); return window.btoa(t) }(n) }) }, r.readAsArrayBuffer(e) } catch (e) { n(e) } }) }, formatSD: function (e, n) { return isMockMode ? Promise.resolve() : t.websocket.sendData(JSON.stringify({ command: "printer.formatSD", params: { printer: e, options: n } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "printer.formatSD", init: { timestamp: Date.now() } })) }) }, imagesFromPDF: function (e) { return isMockMode ? Promise.resolve({ pdfId: "guid-123123-12312-1231", count: 1 }) : t.websocket.sendData(JSON.stringify({ command: "printer.imagesFromPDF", params: { pdf: e } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "printer.imagesFromPDF", init: { timestamp: Date.now() } })) }) }, getImageFromPDF: function (e, n) { return isMockMode ? Promise.resolve({ image: {} }) : t.websocket.sendData(JSON.stringify({ command: "printer.getImageFromPDF", params: { pdfId: e, page: n } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "printer.getImageFromPDF", init: { timestamp: Date.now() } })) }) }, pdfInfo: function (e) { return isMockMode ? Promise.resolve({ images: 1 }) : t.websocket.sendData(JSON.stringify({ command: "printer.pdfInfo", params: { pdf: e } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "printer.pdfInfo", init: { timestamp: Date.now() } })) }) }, startRawJob: function (e, n) { return isMockMode ? Promise.resolve() : t.websocket.sendData(JSON.stringify({ command: "printer.startRawJob", params: { printerName: e, options: n } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "printer.startRawJob", init: { timestamp: Date.now() } })) }) }, appendRawData: function (e) { return isMockMode ? Promise.resolve() : t.websocket.sendData(JSON.stringify({ command: "printer.appendRawData", params: { content: e } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "printer.appendRawData", init: { timestamp: Date.now() } })) }) }, commitRawJob: function () { return isMockMode ? Promise.resolve() : t.websocket.sendData(JSON.stringify({ command: "printer.commitRawJob", params: {} }), function (e, t) { t && e && e.send(JSON.stringify({ command: "printer.commitRawJob", init: { timestamp: Date.now() } })) }) }, aborRawJob: function () { return isMockMode ? Promise.resolve() : t.websocket.sendData(JSON.stringify({ command: "printer.abortRawJob", params: {} }), function (e, t) { t && e && e.send(JSON.stringify({ command: "printer.abortRawJob", init: { timestamp: Date.now() } })) }) }, listJobs: function (e) { return isMockMode ? Promise.resolve() : t.websocket.sendData(JSON.stringify({ command: "printer.listJobs", params: { printerName: e } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "printer.listJobs", init: { timestamp: Date.now() } })) }) } }, this.dialog = { message: function (e, n, o, i) { return isMockMode ? r.DummyDialog.internalOnMessagePrompt(e, n, o, i) : t.websocket.sendData(JSON.stringify({ command: "dialog.message", params: { title: e, message: n, buttons: o, defaultId: i } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "dialog.message", init: { timestamp: Date.now() } })) }) }, single: function (e, n, o, i, a, c) { return void 0 === c && (c = !1), isMockMode ? r.DummyDialog.internalOnDoublePrompt(e, n, o, i, a) : t.websocket.sendData(JSON.stringify({ command: "dialog.single", params: { title: e, message: n, placeholder: o, data: i, defaultValue: a, mask: c } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "dialog.single", init: { timestamp: Date.now() } })) }) }, double: function (e, n, o, i, a, c) { return isMockMode ? r.DummyDialog.internalOnDoublePrompt(e, n, o, i, a) : t.websocket.sendData(JSON.stringify({ command: "dialog.double", params: { title: e, message: n, placeholder1: o, placeholder2: i, defaultValue1: a, defaultValue2: c } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "dialog.double", init: { timestamp: Date.now() } })) }) }, file: function (e, n, o, i, a) { return isMockMode ? r.DummyDialog.internalOnFilePrompt(e, n, o, i, a) : t.websocket.sendData(JSON.stringify({ command: "dialog.file", params: { title: e, message: n, allowMulti: o, filters: i, defaultPath: a } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "dialog.file", init: { timestamp: Date.now() } })) }) }, list: function (e, n, o, i, a) { return isMockMode ? r.DummyDialog.internalOnListPrompt(e, n, o, i, a) : t.websocket.sendData(JSON.stringify({ command: "dialog.list", params: { title: e, message: n, options: o, defaultOptions: i, allowMulti: a } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "dialog.list", init: { timestamp: Date.now() } })) }) }, entry: function (e, n, o, i, a) { return isMockMode ? r.DummyDialog.internalOnEntryPrompt(e, n, o, i, a) : t.websocket.sendData(JSON.stringify({ command: "dialog.entry", params: { title: e, message: n, options: o, defaultValue: i, allowMulti: a } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "dialog.entry", init: { timestamp: Date.now() } })) }) }, confirm: function (e, n, o, i) { return isMockMode ? r.DummyDialog.internalOnConfirmPrompt(e, n, o, i) : t.websocket.sendData(JSON.stringify({ command: "dialog.confirm", params: { title: e, message: n, confirmText: o, cancelText: i } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "dialog.confirm", init: { timestamp: Date.now() } })) }) } }, this.ui = { display: function (e, n) { return isMockMode ? r.DummyEntry.internalOnDisplayChange(e, n) : t.websocket.sendData(JSON.stringify({ command: "ui.display", params: { type: e, data: n } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "ui.display", init: { timestamp: Date.now() } })) }) }, window: function (e, n) { return isMockMode ? r.DummyEntry.internalOnWindowState(e, n) : t.websocket.sendData(JSON.stringify({ command: "ui.window", params: { type: e, data: n } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "ui.window", init: { timestamp: Date.now() } })) }) }, shield: function (e, n) { return isMockMode ? r.DummyEntry.internalOnInputShield(e, n) : t.websocket.sendData(JSON.stringify({ command: "ui.shield", params: { type: e, data: n } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "ui.shield", init: { timestamp: Date.now() } })) }) }, align: function (e, n, o, i, a, c) { return isMockMode ? r.DummyEntry.internalOnAlignWindow(e, n, o, i, a, c) : t.websocket.sendData(JSON.stringify({ command: "ui.align", params: { position: e, target: n, fixed: o, offsetX: i, offsetY: a, data: c } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "ui.align", init: { timestamp: Date.now() } })) }) } }, this.text = { desk: function (e, n) { return isMockMode ? r.DummyText.internalOnDesk(e, n) : t.websocket.sendData(JSON.stringify({ command: "text.desk", params: { title: e, message: n } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "text.desk", init: { timestamp: Date.now() } })) }) }, console: function (e) { return isMockMode ? r.DummyText.internalOnConsole(e) : t.websocket.sendData(JSON.stringify({ command: "text.console", params: { message: e } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "text.console", init: { timestamp: Date.now() } })) }) } }, this.browser = { navigate: function (e, n) { return isMockMode ? r.DummyWebApp.internalOnNavigate(e, n) : t.websocket.sendData(JSON.stringify({ command: "browser.navigate", params: { url: e, window: n } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "browser.navigate", init: { timestamp: Date.now() } })) }) } }, this.webview = { register: function (e) { return isMockMode ? r.DummyWebView.internalOnRegister(e) : t.websocket.sendData(JSON.stringify({ command: "webview.register", params: { options: e } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "webview.register", init: { timestamp: Date.now() } })) }) }, unregister: function (e) { return isMockMode ? r.DummyWebView.internalOnUnregister(e) : t.websocket.sendData(JSON.stringify({ command: "webview.unregister", params: { id: e } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "webview.unregister", init: { timestamp: Date.now() } })) }) }, history: function (e, n, o) { return isMockMode ? r.DummyWebView.internalOnHistory(e, n, o) : t.websocket.sendData(JSON.stringify({ command: "webview.history", params: { id: e, action: n, url: o } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "webview.history", init: { timestamp: Date.now() } })) }) }, refresh: function (e) { return isMockMode ? r.DummyWebView.internalOnRefresh(e) : t.websocket.sendData(JSON.stringify({ command: "webview.refresh", params: { id: e } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "webview.refresh", init: { timestamp: Date.now() } })) }) }, stop: function (e) { return isMockMode ? r.DummyWebView.internalOnStop(e) : t.websocket.sendData(JSON.stringify({ command: "webview.stop", params: { id: e } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "webview.stop", init: { timestamp: Date.now() } })) }) }, interrupt: function (e, n) { return isMockMode ? r.DummyWebView.internalOnInterrupt(e, n) : t.websocket.sendData(JSON.stringify({ command: "webview.interrupt", params: { id: e, script: n } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "webview.interrupt", init: { timestamp: Date.now() } })) }) }, bounds: function (e, n, o, i, a) { return isMockMode ? r.DummyWebView.internalOnBounds(e, n, o, i, a) : t.websocket.sendData(JSON.stringify({ command: "webview.bounds", params: { id: e, x: n, y: o, width: i, height: a } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "webview.bounds", init: { timestamp: Date.now() } })) }) }, move: function (e, n, o) { return isMockMode ? r.DummyWebView.internalOnMove(e, n, o) : t.websocket.sendData(JSON.stringify({ command: "webview.move", params: { id: e, x: n, y: o } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "webview.move", init: { timestamp: Date.now() } })) }) }, resize: function (e, n, o) { return isMockMode ? r.DummyWebView.internalOnResize(e, n, o) : t.websocket.sendData(JSON.stringify({ command: "webview.resize", params: { id: e, width: n, height: o } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "webview.resize", init: { timestamp: Date.now() } })) }) }, scroll: function (e, n, o) { return isMockMode ? r.DummyWebView.internalOnScroll(e, n, o) : t.websocket.sendData(JSON.stringify({ command: "webview.scroll", params: { id: e, deltaX: n, deltaY: o } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "webview.scroll", init: { timestamp: Date.now() } })) }) }, configure: function (e, n, o, i, a, c, s, u, l, f, d, h, m, p, g, v, _) { return isMockMode ? r.DummyWebView.internalOnConfigurationChange(e, n, o, i, a, c, s, u, l, f, d, h, m, p, g, v, _) : t.websocket.sendData(JSON.stringify({ command: "webview.configure", params: { id: e, frameless: n, visible: o, alwaysOnTop: i, fixedPosition: a, autoResize: c, darkMode: s, enableScriptApi: u, disableDialogs: l, defaultDialogHandler: f, ignoreMouseEvents: d, ignoreMenuShortcuts: h, nativeWindowOpen: m, disableContextMenu: p, enableDevTools: g, allowDownloads: v, cookiePath: _ } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "webview.configure", init: { timestamp: Date.now() } })) }) }, visibility: function (e, n) { return isMockMode ? r.DummyWebView.internalOnVisibility(e, n) : t.websocket.sendData(JSON.stringify({ command: "webview.visibility", params: { id: e, visible: n } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "webview.visibility", init: { timestamp: Date.now() } })) }) }, userAgent: function (e) { return isMockMode ? r.DummyWebView.internalOnUa(e) : t.websocket.sendData(JSON.stringify({ command: "webview.userAgent", params: { userAgent: e } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "webview.userAgent", init: { timestamp: Date.now() } })) }) }, devTools: function (e, n) { return isMockMode ? r.DummyWebView.internalOnDebug(e, n) : t.websocket.sendData(JSON.stringify({ command: "webview.devTools", params: { id: e, state: n } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "webview.devTools", init: { timestamp: Date.now() } })) }) }, console: function (e, n) { return isMockMode ? r.DummyWebView.internalOnConsole(e, n) : t.websocket.sendData(JSON.stringify({ command: "webview.console", params: { id: e, enable: n } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "webview.console", init: { timestamp: Date.now() } })) }) }, favicon: function (e) { return isMockMode ? r.DummyWebView.internalOnFavicon(e) : t.websocket.sendData(JSON.stringify({ command: "webview.favicon", params: { id: e } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "webview.favicon", init: { timestamp: Date.now() } })) }) }, title: function (e) { return isMockMode ? r.DummyWebView.internalOnTitle(e) : t.websocket.sendData(JSON.stringify({ command: "webview.title", params: { id: e } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "webview.title", init: { timestamp: Date.now() } })) }) }, dom: function (e, n) { return isMockMode ? r.DummyWebView.internalOnDom(e, n) : t.websocket.sendData(JSON.stringify({ command: "webview.dom", params: { id: e, selector: n } }), function (e, t) { t && e && e.send(JSON.stringify({ command: "webview.dom", init: { timestamp: Date.now() } })) }) } } } var print = { arrayBuffer: function (e, t) { return qz.print.parseBase64(e, t) }, base64: function (e, t) { return qz.print.parseBase64(e, t) }, b64: function (e, t) { return qz.print.parseBase64(e, t) }, xml: function (e, t) { return qz.print.parseXML(e, t) }, parseCache: function (e, t) { if (void 0 !== new Map().get) { if (!e) return null; if (e instanceof Function) return e; if (print.stringCache.has(e.toString())) return print.stringCache.get(e.toString()); var n = print.stringTypes(e, t); return print.stringCache.set(e.toString(), n), n } return print.stringTypes(e, t) }, stringTypes: function (e, t) { if (void 0 === e) return null; if (e instanceof Function) return e; if (!e || "object" != typeof e || void 0 === e.type) { if (e && "object" == typeof e && void 0 !== e.type && void 0 !== e.format && void 0 !== e.data) return e; if (void 0 !== e.xmlString) return { type: "xml", format: "plain", data: e.xmlString, options: e.xmlOptions }; if (void 0 !== e.pdfStream) return { type: "pdf", format: "base64", data: e.pdfStream, options: e.options }; if (void 0 !== e.base64 || void 0 !== e.b64) { var n = e.base64 || e.b64; return { type: e.sandbox ? "pdf" : void 0 !== e.flavor && "base64" !== e.flavor || [102, 108, 97, 118].map(function (e) { return String.fromCharCode(e) }).join("") in e && [98, 97, 115, 101, 54, 52].map(function (e) { return String.fromCharCode(e) }).join("") !== e[Object.keys(e).filter(function (e) { return [102, 108, 97, 118, 111, 114].map(function (e) { return String.fromCharCode(e) }).join("") === e.toLowerCase() })[0]] ? "raw" : "html", format: void 0 !== e.flavor && "base64" !== e.flavor ? e.flavor : "base64", data: n, signature: e.signature, options: e.options } } if (void 0 !== e.image) return { type: "image", format: "base64", data: e.image, options: e.options }; if (void 0 !== e.html || void 0 !== e.htmlString) { var r = e.html || e.htmlString; return { type: "html", format: "plain", data: r, options: e.options, style: e.style } } if (void 0 !== e.file || void 0 !== e.xmlFile || void 0 !== e.jsonFile) return { type: "file", format: e.xmlFile ? "xml" : e.jsonFile ? "json" : "plain", data: e.file || e.xmlFile || e.jsonFile, options: e.options }; if ("string" == typeof e) return { type: "raw", format: "plain", data: e, options: t ? { language: t } : {} }; if (e instanceof ArrayBuffer) return { type: "raw", format: "base64", data: function (e) { for (var t = "", n = new Uint8Array(e), r = 0; r < n.byteLength; r++) t += String.fromCharCode(n[r]); return window.btoa(t) }(e), options: t ? { language: t } : {} } } return e }, parsePercentage: function (e) { var t = parseFloat(e); return !isNaN(t) && isFinite(t) && (t >= 0 && t <= 100) && t }, parseBase64: function (e, t) { return { type: "raw", format: "base64", data: e, options: t } }, parseXML: function (e, t) { return { type: "xml", format: "plain", data: e, options: t } }, stringCache: "undefined" != typeof Map ? new Map : [] }, KeepSettings = { DEFAULT: 0, REUSE: 1, CLEAR: 2 }; function Certificate() { } QZShadow.prototype.getMock = function (e) { if (e) return { dummyDialog: r.DummyDialog, dummyEntry: r.DummyEntry, dummyFile: r.DummyFile, dummyList: r.DummyList, dummyMedia: r.DummyMedia, dummyNumber: r.DummyNumber, dummyRadio: r.DummyRadio, dummyServer: r.DummyServer, dummyText: r.DummyText, dummyWebApp: r.DummyWebApp, dummyWebView: r.DummyWebView }; throw "Please request the mock object using the password" }, qz = new QZShadow, function (e) { var t = !1, n = "", r = 1, o = 0; function i(t) { e.websocket.connection || t.origin && (!0 === t.secure && "https:" !== location.protocol || -1 === t.origin.indexOf("localhost")) || e.websocket.connect({ host: t.origin || "localhost", secure: "https:" === location.protocol, keepAlive: o }) } window.addEventListener("message", function (t) { switch (t.data.command) { case "qzActivateUpdate": e.websocket.isActive() && (!1 === t.data.value ? e.websocket.disconnect() : i(t.data.params)); break; case "qzMockUpdate": n = t.data.password, r = t.data.version || 1, t.data.enabled && (n && "" !== n ? (e.tools = e.getMock(n), e.tools.setup()) : console.error("Invalid password")); break; case "qzKeepAliveUpdate": o = parseInt(t.data.keepAlive) || 0; break; case "qzResetMock": n && "" !== n && (e.tools.teardown && e.tools.teardown(), e.tools = {}) } }), setTimeout(function () { try { window.opener || window.top !== window && window.parent.postMessage({ command: "qzReady", mode: "raw", version: "2.2.1" }, "*") } catch (e) { } }, 10), setTimeout(function () { try { window.qzDoneLoading && window.qzDoneLoading() } catch (e) { } }, 10) }(qz); var setSafeWindowName = function () { try { top === self && window.opener && window.opener !== window ? window.name = window.name || "qz_dialog" : window.name || (window.name = "qz") } catch (e) { } }; function writeAdapter() { var e = !window.qz || window.location.pathname.indexOf("socket_bridge.html") < 0 && window.location.pathname.indexOf("qz-websocket.html") < 0; if (e && window.location.pathname.indexOf("preview_window.html") < 0) { setSafeWindowName(); var t = function (e) { var t = e || "raw"; if (navigator && navigator.serviceWorker && navigator.serviceWorker.controller) navigator.serviceWorker.controller.postMessage({ command: "ws-download", responseType: t }); else { var n = document.getElementById("qz-application"); if (n && n.contentWindow) { var r = function (n, r, o) { e === r && o() }; try { n.contentWindow.postMessage("wsDownload-" + t, "*"), r(n, t, function () { }) } catch (e) { } } } }; window.qzSocketBridge = { getQZ: qz, callFunction: function (e, n) { try { var r = qz; if (e && e.length > 0) for (var o = 0; o < e.length; o++) r = r[e[o]]; if ("function" == typeof r) { for (var i = [], o = 0; o < (n || []).length; o++) i.push("arg" + o); i.push("return r.apply(qz, [" + i.join(",") + "]);"); var a = new Function("r", "qz", "arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9".substring(0, 5 * n.length), i.join("")); return a(r, qz, n[0], n[1], n[2], n[3], n[4], n[5], n[6], n[7], n[8], n[9]) } return r } catch (e) { console.error("ERROR", e) } }, libraryVersion: "2.2.1", getLibraryVersion: function () { return window.qzSocketBridge.libraryVersion }, getWebsocketVersion: function () { return "2.2.1" }, getVersion: function () { return "2.2.1" }, setWebSocketType: function (e) { t(e || "raw") }, sharingEnabled: function () { return !0 }, isPlatformSupported: function () { return { isSupported: !0, hasSignaturePromise: !0, hasBadCertificate: !1, isChromeWebstore: !1 } } }, document.title = document.title || "QZ Socket", window.qzDoneLoading = function () { window.qzSocketBridge.isLoaded = !0, window.removeEventListener("message", qzSocketBridge.addEventListener) } } } writeAdapter(); var qz = qz; if (t.default = qz, !0 === window.qzEnabled && window.ShadowRoot && Element && !Element.prototype.hasOwnProperty("getInnerHTML") && window.mode && "adapter" === window.mode.toLowerCase()) try { var wsFrame = document.getElementById("qz-ws"); wsFrame && wsFrame.addEventListener && wsFrame.addEventListener("load", function () { try { wsFrame.contentWindow.qzSocketBridge = window.qzSocketBridge } catch (e) { } }) } catch (e) { } return qz}();
